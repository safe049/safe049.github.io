<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机科学 on Dysprosium</title>
    <link>https://safe049.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</link>
    <description>Recent content in 计算机科学 on Dysprosium</description>
    <generator>Hugo</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 14 Feb 2026 22:41:53 +0800</lastBuildDate>
    <atom:link href="https://safe049.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MIT SICP 6.001 Lec1b: 计算过程 笔记</title>
      <link>https://safe049.github.io/post/sicp-1/</link>
      <pubDate>Sat, 14 Feb 2026 22:41:53 +0800</pubDate>
      <guid>https://safe049.github.io/post/sicp-1/</guid>
      <description>&lt;h1 id=&#34;笔记&#34;&gt;笔记&lt;/h1&gt;&#xA;&lt;p&gt;代码的计算是如何进行的？或者，过程和程序执行的原理是什么？&lt;/p&gt;&#xA;&lt;p&gt;我们有个简单的模型：代换模型&lt;/p&gt;&#xA;&lt;p&gt;但我们先看看我们前面所写的代码，我们可以找到以下几种表达式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数字&lt;/li&gt;&#xA;&lt;li&gt;符号&lt;/li&gt;&#xA;&lt;li&gt;Lambda表达式 [X]&lt;/li&gt;&#xA;&lt;li&gt;定义表达式 [X]&lt;/li&gt;&#xA;&lt;li&gt;条件表达式 [X]&lt;/li&gt;&#xA;&lt;li&gt;组合式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;标 [x] 的为特殊形式&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;代换规则（Substitution Rule）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;为求值一个应用（application）：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;求值该操作符（operator），得到一个过程（procedure）；&lt;/li&gt;&#xA;&lt;li&gt;求值各操作数（operands），得到各参数（arguments）；&lt;/li&gt;&#xA;&lt;li&gt;将该过程应用于这些参数；&lt;/li&gt;&#xA;&lt;li&gt;将该过程的主体（body）复制一份，并将其中的形式参数（formal parameters）替换为实际提供的参数；&lt;/li&gt;&#xA;&lt;li&gt;对所得的新主体进行求值。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;举例：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(define (sq x) (&lt;span style=&#34;color:#a6e22e&#34;&gt;*&lt;/span&gt; x x))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(sq &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;) &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;; 表达式会成为：&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意 * 也可以继续往下挖，但我们要学会忽略细节，因为计算机的抽象里，你怎么往下挖，都总会有更底层的东西，不去思考不必要的事情&lt;/p&gt;&#xA;&lt;p&gt;代换模型并不是计算机的实际运作方法，但现在先这么想&lt;/p&gt;&#xA;&lt;p&gt;对于一个if语句，会先求值谓词表达式，如果返回真，求值子句表达式，否则，求值选择表达式。&lt;/p&gt;&#xA;&lt;p&gt;但，你写不一样的代码，最后运算中的“形状”也不一样&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(define (&lt;span style=&#34;color:#a6e22e&#34;&gt;+&lt;/span&gt; x y)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      y&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (&lt;span style=&#34;color:#a6e22e&#34;&gt;+&lt;/span&gt; (-1+ x) (&lt;span style=&#34;color:#a6e22e&#34;&gt;1+&lt;/span&gt; y))))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;; 按过程，得到&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另一种写法中，&lt;/p&gt;</description>
    </item>
    <item>
      <title>MIT SICP 6.001 Lec1a: Lisp概览 笔记</title>
      <link>https://safe049.github.io/post/sicp-0/</link>
      <pubDate>Fri, 13 Feb 2026 21:39:53 +0800</pubDate>
      <guid>https://safe049.github.io/post/sicp-0/</guid>
      <description>&lt;h1 id=&#34;sicp&#34;&gt;SICP&lt;/h1&gt;&#xA;&lt;p&gt;这门课其实我很早之前就看过，但看到lec2b发现，我当时还是个2b。&lt;/p&gt;&#xA;&lt;p&gt;于是，我就去修了接近1年，现在决定再来看&lt;/p&gt;&#xA;&lt;p&gt;顺便，祝大家新年快乐&lt;/p&gt;&#xA;&lt;h1 id=&#34;笔记&#34;&gt;笔记&lt;/h1&gt;&#xA;&lt;p&gt;computer so-called science, actually has a lot in common with magic. &amp;ndash; Abelson&lt;/p&gt;&#xA;&lt;p&gt;计算机科学比起科学更像工程或艺术&lt;/p&gt;&#xA;&lt;p&gt;而且，也不能说他关于计算机。&lt;/p&gt;&#xA;&lt;p&gt;因为，几何学虽然字面上叫“地面测量”，但他是关于提供一种空间与时间的形式化表达什么的这样的东西的，而不是关于测量仪器的使用&lt;/p&gt;&#xA;&lt;p&gt;计算机科学也像那样有糟糕的命名。&lt;/p&gt;&#xA;&lt;p&gt;比起计算机，更应该说是对计算过程进行形式化表述：如何对解决问题的过程进行精确的，形式化的表述&lt;/p&gt;&#xA;&lt;p&gt;但几何学只谈论“什么是真的”，而计算机科学谈论“如何解决问题”，而且格外精确&lt;/p&gt;&#xA;&lt;p&gt;数学里，定义x的平方根y是一个其平分=x且大于等于0的数，这是陈述性知识，他告诉了你什么是，但没有告诉你怎么去找到一个&lt;/p&gt;&#xA;&lt;p&gt;而计算机科学里，给出的是指令性知识：&lt;/p&gt;&#xA;&lt;p&gt;要找到x的平方根，做一个猜测g，通过求g和x/g的平均值改善猜测，一直改善直到足够好【heron算法】&lt;/p&gt;&#xA;&lt;p&gt;这是一个过程，告诉了你怎么做某事。&lt;/p&gt;&#xA;&lt;p&gt;那过程通常来说是什么？&lt;/p&gt;&#xA;&lt;p&gt;可以看成一个活在计算机里的精灵，根据你给的叫“程序”的规则模式指导他们做某事，而使用程序控制精灵完成某事就叫作过程&lt;/p&gt;&#xA;&lt;p&gt;所以，计算机科学是巫术。&lt;/p&gt;&#xA;&lt;p&gt;就像巫术要用咒语，计算机科学也需要，lisp就是其中一种。&lt;/p&gt;&#xA;&lt;p&gt;咒语很简单，但就像人人都能很快学会象棋的规则并告诉别人怎么用但却不能理解其蕴涵的内容一样，编程语言也是如此，你可能会用但却不“会”&lt;/p&gt;&#xA;&lt;p&gt;但程序有可能长达上千页，具有高度的复杂性，你也没法一眼全装进脑子，所以我们有在大系统中控制复杂度的技术，这就是计算机科学的关键，也是sicp所谈的。&lt;/p&gt;&#xA;&lt;p&gt;别的领域也要控制复杂度，但cs的复杂度和他们不太一样：&lt;/p&gt;&#xA;&lt;p&gt;cs不太现实。&lt;/p&gt;&#xA;&lt;p&gt;别的领域有公差，近似值，噪音&lt;/p&gt;&#xA;&lt;p&gt;但逻辑上cs没有。你可以随便搞，约束几乎没有。限制你的没有别的东西，而只有你思维的极限。&lt;/p&gt;&#xA;&lt;p&gt;计算机里这个控制复杂度的方法叫作黑盒抽象，将某些东西组合并封装。比如求平方根，把这些操作视作盒子：找到x的平方根 盒子&lt;/p&gt;&#xA;&lt;p&gt;我们输入36,他给我6&lt;/p&gt;&#xA;&lt;p&gt;所以某人想把a平方根+b平方根的时候就不用关心他是怎么实现得了，还可以构建新的盒子&lt;/p&gt;&#xA;&lt;p&gt;基本就是把处理过程放进盒子里隐藏细节，以构建更大的盒子。毕竟，假如你在用电风扇，你不会想看到他一身都是复杂的电路什么的而没有外壳的。&lt;/p&gt;&#xA;&lt;p&gt;函数的不动点是：F(y) = y，输入与输出相等&lt;/p&gt;&#xA;&lt;p&gt;而求解有个技巧，就是把难解的问题转化为找某个精心设计的F的不动点&lt;/p&gt;&#xA;&lt;p&gt;那么，我们就一直把y代入F(y)，再把结果塞进去，无限逼近不动点&lt;/p&gt;&#xA;&lt;p&gt;换句话说，这不就是递归吗？换句话说，盒子可以套盒子，函数可以拿函数做输入，一个过程输出了另一个过程&lt;/p&gt;&#xA;&lt;p&gt;同时，求和运算可以放到任何元素上，电信号，多项式，数，但显然他们加起来的方法不同，为了避免加个别的东西直接全坏掉，我们需要一种接口，一种按照约定实现的接口，对各种不同数据采用同一运算规则，只要每种数据类型都按约定实现这个函数&lt;/p&gt;&#xA;&lt;p&gt;比如说，要写个收银机函数，我们一个一个全部在一个函数内判断什么的，会特别复杂，而且每次改都得重写&lt;/p&gt;&#xA;&lt;p&gt;但我们如果先给每个商品加个类型的标签和对应的定价规则【比如正常，称重，促销】，再加个加个规则表，根据类型对应到各自的定价函数，在写一个通用结账函数，就不用改函数本身，只需要注册一个新的就好&lt;/p&gt;&#xA;&lt;p&gt;我们现在有两种控制复杂度的方法了，黑盒抽象和约定接口&lt;/p&gt;&#xA;&lt;p&gt;而第三种是设计新的语言，你可以看到同样的程序用c和py实现py就更简单，py就隐藏了部分细节，又强调了一些其他的细节，放到lisp上，lisp有一大堆方言，每个都为解决特定问题而生。&lt;/p&gt;&#xA;&lt;p&gt;即元语言抽象，构建新的语言。&lt;/p&gt;&#xA;&lt;p&gt;当有人展示一个语言时，你应该问他：构成语言的基本元素[Primitive Elements]有哪些？他们组合的方法是什么？抽象的方法是什么？&lt;/p&gt;&#xA;&lt;p&gt;lisp的基本元素：3 17.4 5 +&lt;/p&gt;&#xA;&lt;p&gt;组合他们的方法：【把求和运算符运用于他们】&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;17.4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 是运算符[Operators]， 那些数字是运算对象[Operands]&lt;/p&gt;&#xA;&lt;p&gt;组合也可以成为运算对象，比如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;构造组合式是组合的基本需求&lt;/p&gt;&#xA;&lt;p&gt;lisp所用的是前缀表达式，即运算符在运算对象前&lt;/p&gt;</description>
    </item>
    <item>
      <title>Colab Unsloth SFT 快速训练！</title>
      <link>https://safe049.github.io/post/colabunsloth/</link>
      <pubDate>Wed, 19 Feb 2025 20:49:18 +0800</pubDate>
      <guid>https://safe049.github.io/post/colabunsloth/</guid>
      <description>&lt;h1 id=&#34;序言&#34;&gt;序言&lt;/h1&gt;&#xA;&lt;p&gt;大部分人的GPU都没有训练AI的显存要求，而谷歌Colab完全可以解决这一点&lt;/p&gt;&#xA;&lt;p&gt;谷歌Colab可以让你免费使用谷歌的服务器4个小时左右来进行训练&lt;/p&gt;&#xA;&lt;p&gt;并且是一个Jupyter Notebook环境&lt;/p&gt;&#xA;&lt;p&gt;这是它的地址： &lt;a href=&#34;https://colab.research.google.com/&#34;&gt;https://colab.research.google.com/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;这是Unsloth的训练笔记本： &lt;a href=&#34;https://colab.research.google.com/drive/1Ys44kVvmeZtnICzWz0xgpRnrIOjZAuxp&#34;&gt;https://colab.research.google.com/drive/1Ys44kVvmeZtnICzWz0xgpRnrIOjZAuxp&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;准备工作&#34;&gt;准备工作&lt;/h1&gt;&#xA;&lt;p&gt;谷歌Colab可以直接通过谷歌账号登录&lt;/p&gt;&#xA;&lt;p&gt;登录完毕后就可以开始了&lt;/p&gt;&#xA;&lt;h2 id=&#34;修改代码&#34;&gt;修改代码&lt;/h2&gt;&#xA;&lt;p&gt;首先先不要急着运行运行时，先修改一下笔记本的代码&lt;/p&gt;&#xA;&lt;h3 id=&#34;模型下载&#34;&gt;模型下载&lt;/h3&gt;&#xA;&lt;p&gt;首先，修改第二个代码框的这一部分：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;model, tokenizer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FastLanguageModel&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;from_pretrained(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    model_name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;unsloth/Meta-Llama-3.1-8B&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;# 修改这里&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    max_seq_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max_seq_length,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dtype &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dtype,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    load_in_4bit &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; load_in_4bit,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# token = &amp;#34;hf_...&amp;#34;, # use one if using gated models like meta-llama/Llama-2-7b-hf&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将需要修改的部分修改为你要使用的模型，可以直接使用Hugging Face库名&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据集准备&#34;&gt;数据集准备&lt;/h3&gt;&#xA;&lt;p&gt;前往笔记本中的 &lt;code&gt;Data Prep&lt;/code&gt; 部分，修改代码&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;formatting_prompts_func&lt;/span&gt;(examples):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    instructions &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; examples[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;instruction&amp;#34;&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    inputs       &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; examples[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;input&amp;#34;&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    outputs      &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; examples[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;output&amp;#34;&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    texts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; instruction, input, output &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; zip(instructions, inputs, outputs):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# Must add EOS_TOKEN, otherwise your generation will go on forever!&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        text &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; alpaca_prompt&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(instruction, input, output) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; EOS_TOKEN&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        texts&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(text)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; { &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; : texts, }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pass&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;# 以上大部分内容都需要根据数据集修改以符合格式&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; datasets &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; load_dataset&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dataset &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; load_dataset(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yahma/alpaca-cleaned&amp;#34;&lt;/span&gt;, split &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;train&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# 改为你要使用的数据集和Split&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dataset &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dataset&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;map(formatting_prompts_func, batched &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;,)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了符合平日训练的需求，我将使用一个典型的SFT训练数据集来进行修改操作&lt;/p&gt;</description>
    </item>
    <item>
      <title>CS50 2024第一节课的收获</title>
      <link>https://safe049.github.io/post/cs50x1/</link>
      <pubDate>Sat, 21 Dec 2024 23:06:01 +0800</pubDate>
      <guid>https://safe049.github.io/post/cs50x1/</guid>
      <description>&lt;h1 id=&#34;序言&#34;&gt;序言&lt;/h1&gt;&#xA;&lt;p&gt;我在Bilibili上意外刷到了这堂哈佛大学的CS50公开课:&lt;a href=&#34;https://www.bilibili.com/video/BV1jV411Q7L5/&#34;&gt;【4K HDR 自制中英字幕】CS50x 2024 哈佛大学计算机科学和编程艺术入门课程&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;看完第一节可谓是收获颇多&lt;/p&gt;&#xA;&lt;p&gt;如果你懒得看两小时多的课,你也可以看看他们的公开笔记:&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/&#34;&gt;Lecture 0&lt;/a&gt;   [不过我还是建议你看看视频,有很多有趣的内容甚至下课了还有合唱]&lt;/p&gt;&#xA;&lt;h1 id=&#34;内容&#34;&gt;内容&lt;/h1&gt;&#xA;&lt;p&gt;这是第0节课的目录:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#welcome&#34;&gt;Welcome!&lt;/a&gt; &lt;strong&gt;欢迎！&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#whats-ahead&#34;&gt;What’s Ahead&lt;/a&gt; &lt;strong&gt;未来展望&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#community&#34;&gt;Community!&lt;/a&gt; &lt;strong&gt;社区！&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#computer-science&#34;&gt;Computer Science&lt;/a&gt; &lt;strong&gt;计算机科学&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#ascii&#34;&gt;ASCII&lt;/a&gt; &lt;strong&gt;ASCII 码&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#unicode&#34;&gt;Unicode&lt;/a&gt; &lt;strong&gt;统一码&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#representation&#34;&gt;Representation&lt;/a&gt; &lt;strong&gt;表示法&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#algorithms&#34;&gt;Algorithms&lt;/a&gt; &lt;strong&gt;算法&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#pseudocode&#34;&gt;Pseudocode&lt;/a&gt; &lt;strong&gt;伪代码&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#artificial-intelligence&#34;&gt;Artificial Intelligence&lt;/a&gt; &lt;strong&gt;人工智能&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#scratch&#34;&gt;Scratch&lt;/a&gt; &lt;strong&gt;Scratch&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#hello-world&#34;&gt;Hello World&lt;/a&gt; &lt;strong&gt;世界您好&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#hello-you&#34;&gt;Hello, You&lt;/a&gt; &lt;strong&gt;你好&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#meow-and-abstraction&#34;&gt;Meow and Abstraction&lt;/a&gt; &lt;strong&gt;喵喵和抽象&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#conditionals&#34;&gt;Conditionals&lt;/a&gt; &lt;strong&gt;条件&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#oscartime&#34;&gt;Oscartime&lt;/a&gt; &lt;strong&gt;奥斯卡时间&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#ivys-hardest-game&#34;&gt;Ivy’s Hardest Game&lt;/a&gt; &lt;strong&gt;Ivy 最难的游戏&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cs50.harvard.edu/x/2024/notes/0/#summing-up&#34;&gt;Summing Up&lt;/a&gt; &lt;strong&gt;总结&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;整节课是给几乎毫无编程经验的人的&lt;/p&gt;&#xA;&lt;p&gt;开始,先介绍了CS50学院内部的社区还有计算机的运行原理和概念之类的&lt;/p&gt;&#xA;&lt;p&gt;然后讲述了二进制的工作原理,请了7名志愿者[还有他们的机器狗Spot]来演示工作原理&lt;/p&gt;&#xA;&lt;p&gt;然后以此为基础说了&lt;strong&gt;计算机如何理解数字、文本、图像、音乐和视频&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;还说明了&lt;strong&gt;伪编码的基本编程技能&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;以及关于在CS50中使用AI的合理和不合理方法:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;合理: 使用他们的&lt;a href=&#34;cs50.ai&#34;&gt;cs50.ai&lt;/a&gt;鸭子AI助教! 这只鸭子会授人以渔而拒绝授人以鱼&lt;/li&gt;&#xA;&lt;li&gt;不合理: 滥用其他AI服务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;然后讲述了&lt;strong&gt;抽象&lt;/strong&gt;(Abstraction)在编程和生活中的重要性&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
